# index

# 디스크 읽기 방식
디스크 읽기 방식은 순차 i/o와 랜덤 i/o로 나뉜다.

데이터베이스의 성능 튜닝은 결국 디스크 i/o를 어떻게줄이느냐의 문제다.

## HDD와 SSD
SSD는 **플래시 메모리**를 사용한다. 그래서 **HDD와 달리 플래터를 회전할 필요가 없기 때문에** 데이터를 읽고 쓰는 시간이 상대적으로 빠르다. 즉, 메모리보다는 느리지만 하드 디스크보다는 빠르다. 요즘 DBMS용으로는 SSD를 많이 채택하고 있다.

디스크의 헤더를 움직이지 않고 데이터를 읽는 방식인 **순차 I/O는 HDD와 SSD 간 성능 차이가 별로 없다**. 하지만 SSD는 **랜덤 i/o에서 헤더를 움직일 필요가 없기 때문에** HDD보다 성능상 이점이 존재한다.

**인덱스 레인지 스캔은 주로 랜덤 i/o**를 사용하고 **풀 테이블 스캔은 순차 i/o**를 사용한다. 쿼리를 튜닝해서 랜덤 i/o를 순차 i/o를 바꾸는 방법은 많지 않다. 이때문에 쿼리를 튜닝하는 것은 랜덤 i/o 횟수를 줄이는데 집중된다.

# 인덱스란?
데이터를 정렬해둔 색인이라 할 수 있으며 쓰기 성능을 희생하여 읽기 성능을 취한 기능이다. 그렇다고 읽기 성능을 가지기 위해 모든 컬럼을 인덱스로 생성하는 것은 고려해야 하는 사항이다. 데이터 **저장 성능이 떨어지고 인덱스의 크기가 커지기 때문에** 공간도 많이 잡아 먹는 행위가 될 수 있기 때문이다.

인덱스는 여러가지로 분류할 수 있다.

역할별
- 프라이머리 키, 세컨더리 인덱스

데이터 저장 방식
- B-Tree, Hash

중복 여부
- Unique, non-Unique

# B-Tree 인덱스
B-tree의 B는 Binary가 아닌 **Balanced**를 의미한다.

## B-Tree의 구조 및 특성
B-tree의 구성으론 **루트 노드, 브랜치 노드, 리프 노드**가 존재한다. 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값(innoDB는 PK)를 가진다.

InnoDB는 세컨더리 인덱스의 리프 노드에 프라이머리 키를 갖는데, 이 때문에 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 검색해야만 한다.

## B-Tree 인덱스 키 추가 및 삭제

### B-Tree 인덱스 추가
새로운 키 값이 B-Tree에 저장될 때 바로 저장될 수도 있고 저장되지 않을 수도 있다. 우선 일반적인 인덱스 추가 과정을 살펴보자.

1. key 값으로 저장하려는 위치를 검색한다.
2. 저장할 위치가 결정되면 key 값과 주소 정보를 리프 노드에 저장한다.

이때, 해당 리프 노드가 꽉 차서 더는 저장할 수 없는 경우가 생긴다. 이때 리프 노드 페이지는 **분리**된다.

3. 리프 페이지를 새로 생성한다.
4. 기존 노드의 데이터를 신규 페이지에 저장한다.
5. 리프 노드에 인덱스를 추가한다.

![](https://www.percona.com/blog/wp-content/uploads/2017/04/Locality_7.png)
![](https://www.percona.com/blog/wp-content/uploads/2017/04/Locality_8.png)
![](https://www.percona.com/blog/wp-content/uploads/2017/04/Locality_10.png)

출처 - https://www.percona.com/blog/innodb-page-merging-and-page-splitting/

innoDB에서 프라이머리 키나 유니크 인덱스가 아닌 경우에는 체인지 버퍼를 활용하여 인덱스 쓰기를 지연시킬 수 있다.

### B-Tree 인덱스 삭제
리프 노드를 찾아 삭제 마킹만 한다. 이 마킹 작업 또한 디스크 쓰기가 필요하여 **디스크 i/o가 발생**한다. 삭제 마킹된 공간은 재사용되거나 방치할 수 있다.

### B-Tree 인덱스 키 변경
인덱스 키 값에 따라 위치가 결정되기 때문에 **키 값만 변경하는 것은 불가능**하다. 키 값을 먼저 삭제한 후, 새로운 키 값을 추가하는 방식으로 진행된다.

### B-Tree 인덱스 키 검색
B-Tree 인덱스를 이용한 검색은 값의 앞부분만 일치하는 경우에 사용할 수 있다. 키 값의 뒷부분만 검색하는 경우에는 인덱스를 사용할 수 없다.
-> **index condition pushdown** 최적화가 있긴 함

## B-tree 인덱스 사용에 영향을 미치는 요소
**칼럼 크기, 레코드 건수, 인덱스 키 값의 개수** 등이 영향을 받는다.

### 인덱스 키 값의 크기
인덱스의 단위는 페이지, 혹은 블록이라고 하며 **디스크의 모든 읽기 쓰기**와 **버퍼 풀에서 데이터를 버퍼링**하는 **기본 단위**가 된다. B-Tree는 자식 노드를 이진 트리보다 많이 가질 수 있다.

**그렇다면 몇개까지 노드를 가질 수 있을까?**

이는 **인덱스 페이지의 크기와 키 값의 크기**에 따라 결정된다. innodb_page_size 시스템 변수를 이용해 4KB ~ 16KB 값을 선택할 수 있고 기본 크기는 16KB이다.

인덱스는 key와 자식 노드 주소(일반적으로 6byte ~ 12byte)로 구성된다. 이때 인덱스 Key가 16byte이고 자식 노드 주소 12byte라고 가정해보자. 

**그렇다면 16KB 인덱스 페이지에는 몇개의 키를 저장할 수 있을까?**

16*1024/(16+12) = 585개를 저장할 수 있게 된다. 최종적으로 16KB 인덱스 페이지는 자식 노드를 585개를 가질 수 있게 된다.

이때 분모인 인덱스의 키 값이 커지면 어떻게 될까? 위의 케이스에서 인덱스가 32byte로 증가한다면?

16*1024/(32+12) = 372개를 저장할 수 있게 된다. 기존의 select 쿼리가 500개의 데이터를 조회할 때는 인덱스 페이지를 하나만 조회하면 됐지만 인덱스 키 값이 증가하자, 두개의 페이지를 조회하게 된다. 즉 **디스크 i/o가 2번 이상** 읽어난다는 것이다.

버퍼풀의 공간 역시 마찬가지다. 저장할 수 있는 인덱스의 크기가 증가했기 때문에 **메모리에 캐시할 수 있는 레코드 수가 줄어든다**.

### 선택도(기수성)

인덱스 키 값 중에 중복 값이 많아지면 기수성은 낮아지고 선택도 또한 떨어진다.




# R-Tree 인덱스

# 멀티 밸류 인덱스

# 클러스터링 인덱스

# 유니크 인덱스

# 외래키
