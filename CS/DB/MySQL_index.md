# index

# 디스크 읽기 방식
디스크 읽기 방식은 순차 i/o와 랜덤 i/o로 나뉜다.

데이터베이스의 성능 튜닝은 결국 디스크 i/o를 어떻게줄이느냐의 문제다.

## HDD와 SSD
SSD는 **플래시 메모리**를 사용한다. 그래서 **HDD와 달리 플래터를 회전할 필요가 없기 때문에** 데이터를 읽고 쓰는 시간이 상대적으로 빠르다. 즉, 메모리보다는 느리지만 하드 디스크보다는 빠르다. 요즘 DBMS용으로는 SSD를 많이 채택하고 있다.

디스크의 헤더를 움직이지 않고 데이터를 읽는 방식인 **순차 I/O는 HDD와 SSD 간 성능 차이가 별로 없다**. 하지만 SSD는 **랜덤 i/o에서 헤더를 움직일 필요가 없기 때문에** HDD보다 성능상 이점이 존재한다.

**인덱스 레인지 스캔은 주로 랜덤 i/o**를 사용하고 **풀 테이블 스캔은 순차 i/o**를 사용한다. 쿼리를 튜닝해서 랜덤 i/o를 순차 i/o를 바꾸는 방법은 많지 않다. 이때문에 쿼리를 튜닝하는 것은 랜덤 i/o 횟수를 줄이는데 집중된다.

<br>

# 인덱스란?
데이터를 정렬해둔 색인이라 할 수 있으며 쓰기 성능을 희생하여 읽기 성능을 취한 기능이다. 그렇다고 읽기 성능을 가지기 위해 모든 컬럼을 인덱스로 생성하는 것은 고려해야 하는 사항이다. 데이터 **저장 성능이 떨어지고 인덱스의 크기가 커지기 때문에** 공간도 많이 잡아 먹는 행위가 될 수 있기 때문이다.

인덱스는 여러가지로 분류할 수 있다.

역할별
- 프라이머리 키, 세컨더리 인덱스

데이터 저장 방식
- B-Tree, Hash

중복 여부
- Unique, non-Unique

<br>

# B-Tree 인덱스
B-tree의 B는 Binary가 아닌 **Balanced**를 의미한다.

<br>

## B-Tree의 구조 및 특성
B-tree의 구성으론 **루트 노드, 브랜치 노드, 리프 노드**가 존재한다. 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가기 위한 주솟값(innoDB는 PK)를 가진다.

InnoDB는 세컨더리 인덱스의 리프 노드에 프라이머리 키를 갖는데, 이 때문에 데이터 레코드를 읽기 위해서는 반드시 프라이머리 키를 저장하고 있는 B-Tree를 검색해야만 한다.

<br>

## B-Tree 인덱스 키 추가 및 삭제

<br>

### B-Tree 인덱스 추가
새로운 키 값이 B-Tree에 저장될 때 바로 저장될 수도 있고 저장되지 않을 수도 있다. 우선 일반적인 인덱스 추가 과정을 살펴보자.

1. key 값으로 저장하려는 위치를 검색한다.
2. 저장할 위치가 결정되면 key 값과 주소 정보를 리프 노드에 저장한다.

이때, 해당 리프 노드가 꽉 차서 더는 저장할 수 없는 경우가 생긴다. 이때 리프 노드 페이지는 **분리**된다.

3. 리프 페이지를 새로 생성한다.
4. 기존 노드의 데이터를 신규 페이지에 저장한다.
5. 리프 노드에 인덱스를 추가한다.

![](https://www.percona.com/blog/wp-content/uploads/2017/04/Locality_7.png)
![](https://www.percona.com/blog/wp-content/uploads/2017/04/Locality_8.png)
![](https://www.percona.com/blog/wp-content/uploads/2017/04/Locality_10.png)

출처 - https://www.percona.com/blog/innodb-page-merging-and-page-splitting/

innoDB에서 프라이머리 키나 유니크 인덱스가 아닌 경우에는 **체인지 버퍼**를 활용하여 **인덱스 쓰기를 지연**시킬 수 있다.

<br>

### B-Tree 인덱스 삭제
리프 노드를 찾아 삭제 마킹만 한다. 이 마킹 작업 또한 디스크 쓰기가 필요하여 **디스크 i/o가 발생**한다. 삭제 마킹된 공간은 재사용되거나 방치할 수 있다.

<br>

### B-Tree 인덱스 키 변경
인덱스 키 값에 따라 위치가 결정되기 때문에 **키 값만 변경하는 것은 불가능**하다. 키 값을 먼저 삭제한 후, 새로운 키 값을 추가하는 방식으로 진행된다.

<br>

### B-Tree 인덱스 키 검색
B-Tree 인덱스를 이용한 검색은 값의 앞부분만 일치하는 경우에 사용할 수 있다. 키 값의 뒷부분만 검색하는 경우에는 인덱스를 사용할 수 없다.
-> **index condition pushdown** 최적화가 있긴 함

<br>

## B-tree 인덱스 사용에 영향을 미치는 요소
**칼럼 크기, 레코드 건수, 인덱스 키 값의 개수** 등이 영향을 받는다.

<br>

### 인덱스 키 값의 크기
인덱스의 단위는 페이지, 혹은 블록이라고 하며 **디스크의 모든 읽기 쓰기**와 **버퍼 풀에서 데이터를 버퍼링**하는 **기본 단위**가 된다. B-Tree는 자식 노드를 이진 트리보다 많이 가질 수 있다.

**그렇다면 몇개까지 노드를 가질 수 있을까?**

이는 **인덱스 페이지의 크기와 키 값의 크기**에 따라 결정된다. innodb_page_size 시스템 변수를 이용해 4KB ~ 16KB 값을 선택할 수 있고 기본 크기는 16KB이다.

인덱스는 key와 자식 노드 주소(일반적으로 6byte ~ 12byte)로 구성된다. 이때 인덱스 Key가 16byte이고 자식 노드 주소 12byte라고 가정해보자. 

**그렇다면 16KB 인덱스 페이지에는 몇개의 키를 저장할 수 있을까?**

16*1024/(16+12) = 585개를 저장할 수 있게 된다. 최종적으로 16KB 인덱스 페이지는 자식 노드를 585개를 가질 수 있게 된다.

이때 분모인 인덱스의 키 값이 커지면 어떻게 될까? 위의 케이스에서 인덱스가 32byte로 증가한다면?

16*1024/(32+12) = 372개를 저장할 수 있게 된다. 기존의 select 쿼리가 500개의 데이터를 조회할 때는 인덱스 페이지를 하나만 조회하면 됐지만 인덱스 키 값이 증가하자, 두개의 페이지를 조회하게 된다. 즉 **디스크 i/o가 2번 이상** 읽어난다는 것이다.

버퍼풀의 공간 역시 마찬가지다. 저장할 수 있는 인덱스의 크기가 증가했기 때문에 **메모리에 캐시할 수 있는 레코드 수가 줄어든다**.

<br>

### 선택도(기수성)
인덱스 키 값 중에 중복 값이 많아지면 기수성은 낮아지고 선택도 또한 떨어진다. 만약 중복도가 높으면 불필요한 데이터를 많이 읽을 가능성이 높다. 아래 예시를 살펴보자.

address 테이블의 country와 city 테이블이 존재한다. 이때 city가 모두 고유한 값을 갖고 있다고 가정한다.(즉, 모두 unique하다고 하자.)


```sql
select *
from address
where country='KOREA' and city ='SEOUL'; 
```

이때 country의 데이터가 10000건이며, 유니크 값이 10개(중복도가 높음)이거나 1000개(중복도가 낮음)라고 생각하면 어떤 경우가 더 효율적일까?

정답은 중복도가 낮을 때이다. 왜냐하면 전자는 seoul을 검색하기 위해 불필요하게 999개를 검색하게 되고 후자는 9건만 불필요하게 읽은 셈이기 때문이다. 이처럼 인덱스를 설정할 때 **유니크한 값의 개수**는 중요한 기준이 된다.

<br>

### 읽어야 하는 레코드의 건수
만약 테이블의 데이터가 100만건인데 읽어야 할 데이터가 50만건이라면 인덱스를 통해 스캔할지, 테이블을 조회할지 결정해야만 한다. 왜냐하면 **인덱스를 통한 읽기는 비용이 많이 드는 작업**이기 때문이다. 인덱스를 통해 레코드를 1건 읽는 것은 테이블에서 직접 레코드를 읽는 것보다 **4~5배 정도 비용이 더 많이 드는 작업**인 것으로 예측된다.

즉, **읽어야 할 레코드 건수가 전체 테이블 레코드의 20~25%인 경우**는 인덱스를 사용하지 않고 테이블을 조회하는 것이 더 효율적이다.

<br>

## B-Tree 인덱스를 통한 데이터 읽기

### 인덱스 레인지 스캔
검색할 범위가 결정됐을 때 선택되는 방식이다. 값의 수나 레코드 건수와 상관 없이 레인지 스캔이라고 한다. 루트 노드부터 브랜치 노드를 거쳐 리프 노드까지 찾아 들어가면 필요한 시작 지점을 찾을 수 있고 순서대로 쭉 읽는다.

![range_scan.jpeg](..%2F..%2Fimg%2Fdb%2Frange_scan.jpeg)

만약 리프 노드의 레코드 주소를 통해 데이터 파일을 조회해야 하면 레코드 한 건, 한 건 단위로 랜덤 i/o가 발생한다. 만약 레인지 스캔으로 찾은 데이터가 3건인데 **모두 데이터 파일에서 레코드를 가져와야 한다면 총 3번의 랜덤 i/o가 발생한다**고 볼 수 있다.

<br>

#### 커버링 인덱스
만약 커버링 인덱스로 처리되는 쿼리라면 디스크의 레코드를 읽지 않아도 되기 때문에 랜덤 읽기가 줄어든다.

<br>

### 인덱스 풀 스캔
인덱스 레인지 스캔과를 다르게 인덱스의 처음부터 끝까지 모두 읽는 방식을 의미한다.

![full_scan.jpeg](..%2F..%2Fimg%2Fdb%2Ffull_scan.jpeg)

인덱스 풀 스캔으로 처리되는 경우는 아래와 같다.
1. where절에 사용된 칼럼이 **인덱스 첫번째 컬럼이 아닌 경우**
2. **커버링 인덱스**인 경우

인덱스 전체 크기는 테이블 자체 크기보다 작기 때문에 테이블 풀 스캔보다 적은 디스크 i/o로 쿼리를 처리할 수 있다.

<br>

### 루스 인덱스 스캔
오라클의 인덱스 스킵 스캔과 유사하지만 5.7까지 MySQL은 루스 인덱스 스캔이라고 한다. 듬성듬성하게 인덱스를 읽는 것을 의미한다.

중간에 필요하지 않은 인덱스는 skip하고 다음으로 넘어가는 형태로 처리한다. **group by** 혹은 **max(), min()** 함수에 대한 최적화를 할 때 사용된다.

<br>

### 인덱스 스킵 스캔 (8.0부터 도입)
인덱스의 첫번째 칼럼이 업는 where 조건절의 검색을 위해 사용 가능해졌기 때문에 범위가 넓어졌다.

```sql
mysql> explain
    -> select gender, birth_date
    -> from employees
    -> where birth_date >='1965-02-01'
    -> ;
+----+-------------+-----------+------------+-------+---------------------+---------------------+---------+------+------+----------+----------------------------------------+
| id | select_type | table     | partitions | type  | possible_keys       | key                 | key_len | ref  | rows | filtered | Extra                                  |
+----+-------------+-----------+------------+-------+---------------------+---------------------+---------+------+------+----------+----------------------------------------+
|  1 | SIMPLE      | employees | NULL       | range | ix_gender_birthdate | ix_gender_birthdate | 4       | NULL | 2527 |   100.00 | Using where; Using index for skip scan |
+----+-------------+-----------+------------+-------+---------------------+---------------------+---------+------+------+----------+----------------------------------------+
1 row in set, 1 warning (0.01 sec)
```

=> ix_gender_birthdate 인덱스에 gender는 where 절에 없지만 birth_date만을 사용하여 조회했다.

이는 옵티마이저가 내부적으로 아래와 같이 처리한다.

```sql
select gender, birth_date from employees where gender ='M' birth_date >='1965-02-01';
select gender, birth_date from employees where gender ='F' birth_date >='1965-02-01';
```

하지만 인덱스 스킵 스캔은 다음과 같은 단점이 존재한다.

1. **선언되지 않은 선행 칼럼의 유니크한 값의 개수가 적어야** 함 ex) gender
2. 커버링 인덱스여야 함

예를 들어, 선언되지 않은 선행 칼럼이 emp_no인 경우 사원 수만큼 스캔을 하기 때문에 쿼리의 성능이 매우 떨어진다.

<br>

## 다중 칼럼(Multi-column) 인덱스
두 개 이상의 칼럼으로 구성된 인덱스를 다중 칼럼 인덱스라고 하며, 첫번째 칼럼에 의존하여 후속 칼럼들이 정렬된다는 특징을 갖는다.

<br>

## B-Tree 인덱스의 정렬 및 스캔 방향
인덱스 생성 시 정렬 방향을 선택하여 생성할 수 있다. 

```sql
create index ix_teamname_userscore on employees (team_name asc, user_score desc);
```

역순 정렬 쿼리가 정순 정렬 쿼리보다 28.9% 시간이 더 걸리므로 자주 사용되는 정렬 순서대로 인덱스를 생성하는 것이 잠금 병목 현상을 완화하는데 도움이 될 수 있다.

<br>

## B-Tree 인덱스의 가용성과 효율성
where 조건절이나 group by, order by 절이 어떤 경우 인덱스를 사용할 수 있는지 알아야 한다.

<br>

### 비교 조건의 종류와 효율성
다중 컬럼 인덱스에서 동등 비교("=")인지 범위 조건(크다, 작다)인지에 따라 활용 형태와 효율 형태가 달라진다.

```sql
select *
from dept_emp
where dept_no='d002' and emp_no >= 10114;
```

작업의 범위를 결정하는 조건은 **작업 범위 결정 조건**이고 단순히 거름종이 역할만 하는 것을 **필터링 조건** 혹은 **체크 조건**이라 한다. 체크 조건은 많다고 해서 쿼리의 성능을 높이지는 못한다. (인덱스 조회 범위를 줄이지는 못하기 때문에)

<br>

### 인덱스의 가용성
B-Tree 인덱스는 왼쪽 값에 기준해서 오른쪽 값이 정렬되어 있다. 그렇기 때문에 왼쪽 칼럼의 값을 모르면 인덱스 레인지 스캔을 사용할 수 없다.

```sql
mysql> explain select * from employees where first_name like '%mer';
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
| id | select_type | table     | partitions | type | possible_keys | key  | key_len | ref  | rows   | filtered | Extra       |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
|  1 | SIMPLE      | employees | NULL       | ALL  | NULL          | NULL | NULL    | NULL | 298980 |    11.11 | Using where |
+----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+-------------+
1 row in set, 1 warning (0.00 sec)
```

인덱스 왼쪽 값 규칙은 group by나 order by에도 똑같이 적용된다.

<br>

### 가용성과 효율성 판단
작업 범위 결정 조건으로 사용할 수 없는 경우
- not equal로 비교되는 경우 
  - (<>, not in, not between, is not null)
- like '%???' 형태로 문자열 패턴이 비교된 경우
- 스토어드 함수나 다른 연산자로 인덱스 칼럼이 변형된 경우
  - where substring(column,1,1) = 'X'
- 데이터 타입이 서로 다른 비교
  - where char_column = 10
- 문자열 데이터 타입의 콜레이션이 다른 경우
- column_1 칼럼에 대한 조건이 없는 경우
- column_1 칼럼 비교 조건이 인덱스 사용 불가 조건인 경우 (위의 not equal, like '%??' 등등)


<br>

# R-Tree 인덱스, 전문 검색 인덱스, 함수 기반 인덱스 (skip)
인덱스를 구성하는 칼럼 값이 2차원 공간 개념 값이라고 한다.


<br>

# 멀티 밸류 인덱스
모든 인덱스는 레코드 1건이 1개의 인덱스 키 값을 가진다. 멀티 밸류 인덱스는 **하나의 레코드가 여러개의 키 값을 가질 수 있는 형태의 인덱스**를 의미한다.

json 데이터 타입을 지원하면서 해당 데이터에 대한 인덱스 요건이 발생한 것이다. **member_of(), json_contains(), json_overlaps()** 등을 활용해야만 인덱스를 활용한 실행 계획을 수립할 수 있다.

<br>

# 클러스터링 인덱스
## 클러스터링 인덱스
테이블의 레코드를 **비슷한 것들끼리 묶어서 저장**하는 형태로 구현된다. 클러스터링 인덱스는 **프라이머리 키에만 적용**된다.

즉, **프라이머리 키 값이 비슷한 것들끼리 묶어 저장하는 것**을 클러스터링 인덱스라고 한다. 프라이머리 키 값에 의해 저장 위치가 결정되기 때문에 테이블에 레코드를 저장하는 방식이라고 봐도 된다.

만약 PK가 없으면 어떻게 클러스터링 테이블로 구성될까?

1. PK가 있으면 클러스터링 키로 PK를 선택
2. **NOT NULL + Unique 인덱스** 중 첫번째 인덱스를 키로 선택
3. 자동으로 유니크한 값을 가지도록 내부적으로 추가한 후, 클러스터링 키로 선택

3번은 아무 의미 없는 값으로 클러스터링되기 때문에 아무런 혜택을 주지 않는다. 가능하다면 PK를 명시하자.

<br>

## 세컨더리 인덱스에 미치는 영향
만약 innoDB 환경에서 세컨더리 인덱스의 리프 노드에 PK가 아닌 실제 저장된 주소의 위치를 가지고 있으면 어떨까? 우선 클러스터링 인덱스의 성격 상, 데이터가 저장될 때마다 레코드의 저장 위치는 계속 변경될 것이다. 그렇다면 세컨더리 인덱스의 리프 노드에 저장된 주소 역시 계속 변경될 것이다.

이러한 문제점으로 인하여 세컨더리 인덱스의 리프 노드에는 레코드가 저장된 주소가 아니라 **프라이머리 키 값을 저장**하도록 되어 있는 것이다.

<br>

## 클러스터링 인덱스의 장단점
### 클러스터링 인덱스의 장점
- 검색할 때 성능이 매우 빠르다.
- 세컨더리 인덱스가 PK를 가지고 있기 때문에 인덱스만으로 처리할 수 있는 경우가 많다. (커버링 인덱스)

<br>

### 단점
- 클러스터링 키 값의 크기가 커지면 인덱스의 크기도 커진다.
- 세컨더리 인덱스로 검색할 때 프라이머리 키 값으로 다시 한 번 검색해야 한다.
- insert 할 때 pk에 의해 저장위치가 결정되기 때문에 쓰기 성능이 저하된다.
- 프라이머리 키를 변경할 때 delete 후, insert하기 때문이 느리다.

결국 장점은 **빠른 읽기**이고 단점은 **느린 쓰기**라는 것을 알 수 있다.

<br>

## 클러스터링 테이블 주의 사항
- 클라스터링 인덱스의 키 크기 (모든 세컨더리 인덱스에 저장되기 때문에 인덱스가 커질 수 있다.)
- auto_increment보다 업무적인 컬럼으로 생성하자.
- 프라이머리 키 값은 반드시 명시하자.
- 세컨더리 인덱스보다 필요하고 프라이머리 키 크기도 길다면 auto_increment를 활용하여 인조 식별자를 만들어 사용해보자.

<br>

# 유니크 인덱스
세컨더리 인덱스와 아무런 차이가 없다. 다만 읽기와 성능 관점에서 살펴보자.

<br>

## 유니크 인덱스 vs 세컨더리 인덱스

### 유니크 인덱스 읽기
유니크 인덱스가 더 빠르다는 말이 있지만 사실이 아니다. 인덱스 특성 때문에 느린 것이 아니기 때문에 성능상 차이는 미미하다.

<br>

### 유니크 인덱스 쓰기
유니크 인덱스는 **중복값 여부를 판단**하기 때문에 일반 세컨더리 인덱스보다 느리다. MySQL에서 유니크 인덱스의 중복 값을 판별하는 과정에서 **읽기 잠금을 사용하고, 쓰기 시에는 쓰기 잠금**을 사용하기 때문에 **데드락이 빈번**히 발생한다.

또한 innoDB에서는 인덱스 키의 저장을 버퍼링하기 위해 체인지 버퍼를 사용하는데 유니크 인덱스는 중복 체크를 해야하므로 버퍼링 기능을 사용하지 못한다. 이 때문에 쓰기 작업 시 일반 인덱스보다 느리다.

<br>

## 유니크 인덱스 주의사항
불필요하게 유니크 인덱스를 생성하지 않는 것이 좋다. 유일성이 보장되어야 하는 칼럼에는 유니크 인덱스를 생성하되, 꼭 필요하지 않다면 세컨더리 인덱스를 고려해보자.

<br>

# 외래키
외래키 제약이 설정되면 자동으로 연관된 테이블 칼럼에 인덱스까지 생성된다. 외래키 관련해서는 중요한 두가지 특성이 존재한다.

- 테이블의 변경이 발생하는 경우에는 잠금 경합(잠금 대기)가 발생한다.
- **외래키와 연관되지 않은 칼럼의 변경**은 최대한 잠금 경합(잠금 대기)를 발생시키지 않는다.
