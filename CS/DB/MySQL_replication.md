# 복제 (replication)
데이터베이스에서 복제는 **확장성(Scalability)과 가용성(Availability)**을 위해 사용되는 기술이다.

# 개요
복제는 **한 서버의 데이터가 다른 서버로 동기화 되는 것**을 의미한다. 그래서 원본 데이터를 가진 서버를 **source server(혹은 마스터 서버)**, 복제된 데이터를 가지는 서버를 **replica server(슬레이브 서버)**라고 한다.

소스 서버의 변경 내역을 레플리카 서버에서 전달 받아 자신의 데이터에 반영하여 동기화 시킨다. 이러한 레플리카 서버를 구축하는 목적은 여러개이다.

1. scale-out
   - 한 서버에 대한 트래픽 증가 시, 부하가 높아지면 일반적으로 scale-up한다. 하지만 이는 한계가 있기 때문에 **트래픽을 분산 시키기 위해 요청을 처리하는 서버를 여러개 두는 방식**을 사용한다. 이를 scale-out이라고 한다.
2. 데이터 백업
   - 사용자의 실수로 데이터가 삭제되면 치명적인 문제를 불러일으킬 수 있다. 이런 문제를 보완하기 위해 데이터 백업은 필수이며 **레플리카 서버를 구축하고, 데이터 백업을 레플리카 서버에서 실행**한다. 이렇게 구축된 레플리카 서버는 소스 서버에 문제가 생겼을 때 대체 서버가 되기도 한다.
3. 데이터 분석
   - 분석용 쿼리는 대부분 **대량의 데이터를 조회**하는 경우가 많아서 **쿼리를 실행할 때 리소스를 많이 사용**한다. 레플리카 서버를 구축하여 분석용 쿼리만 전용으로 사용하게 만든다.
4. 데이터의 지리적 분산
   - 애플리케이션 서버에서 떨어져 있는 DB 서버를 지리상 옮기지 못한다면 레플리카 서버를 따로 구축해서 응답 속도를 개선할 수 있다.

<br>

# 복제 아키텍처
MySQL의 변경사항은 모두 로그 파일에 순서대로 기록된다. 이 로그를 **바이너리 로그**라고 한다. 여기서 변경사항은 데이터의 변경 내역뿐만 아니라 스키마 변경, 권한 변경 정보도 모두 포함된다. 바이너리 로그 파일에 기록된 각 정보들을 **이벤트** 라고도 한다.

MySQL의 복제는 이 바이너리 로그 기반으로 진행되는데 소스 서버의 바이너리 로그가 레플리카 서버로 전달되고 레플리카 서버는 해당 로그를 로컬 디스크에 저장한 뒤, 자신이 가진 테이블에 반영한다. 레플리카 서버에서 바이너리 로그를 읽어서 자신의 로컬 디스크에 저장한 로그 파일을 **릴레이 로그**라 한다.

## 복제 스레드
![mysql_replication_architecture.png](..%2F..%2Fimg%2Fdb%2Fmysql_replication_architecture.png)
출처 - Real MySQL 8.0

복제는 총 세개의 스레드가 동작한다. 각 스레드의 역할은 아래와 같다.

- **바이너리 로그 덤프 스레드** : 레플리카 서버는 동기화할 때 **소스 서버에 접속해서 바이너리 로그 정보를 요청**한다. **소스 서버**는 레플리카 서버와 **연결되면** 바이너리 로그 덤프 **스레드를 생성**해서 **바이너리 로그 내용을 레플리카 서버로 전송**한다.
- **레플리케이션 I/O 스레드** : **복제가 시작(start replica)되면 레플리카 서버는 i/o 스레드를 생성**해서 바이너리 로그 덤프 스레드로부터 이벤트를 가져와 **릴레이로그에 저장**하는 역할을 한다.
- **레플리케이션 SQL 스레드** : 릴레이 로그 파일의 이벤트를 읽고 실행한다.

레플리케이션 I/O 스레드와 SQL 스레드는 독립적으로 실행된다. SQL 스레드가 느려 반영이 느리더라도 I/O 스레드가 이벤트를 가져와 로그에 저장하는 작업과는 무관하다.

## 레플리카 서버가 관리하는 데이터 유형
복제가 시작(start replica)되면 레플리카 서버는 총 세가지 유형의 데이터를 생성하고 관리한다. **릴레이 로그, 커넥션 메타데이터, 어플라이어 메타데이터**다.

- **릴레이 로그** : I/O 스레드에 의해 작성되는 파일이다. 바이너리 로그와 마찬가지로 현재 릴레이 로그 파일들의 목록이 담긴 **인덱스 파일**과 실제 이벤트 정보가 저장된 **로그 파일**로 구성된다.
- **커넥션 메타데이터** : I/O 스레드가 소스 서버에 접속할 때 사용되는 **계정 정보 및 현재 읽고 있는 바이너리 파일명과 파일 위치 값이** 담겨있다. mysql.slave_master_info 테이블에 저장된다. 
- **어플라이어 메타데이터** : SQL 스레드에서 레플리카 서버에 적용하는 컴포넌트를 **어플라이어**라고 한다. 최근 적용된 이벤트가 저장되어 있는 **릴레이 로그 파일명과 파일 내 위치 정보** 등이 담겨 있다. 이 정보를 바탕으로 레플리카 서버에서 나머지 이벤트를 적용한다. mysql.slave_relay_log_info에 저장된다.

커넥션 메타데이터와 어플라이어 메타데이터는 어떤 형태로 데이터를 관리할지 정할 수 있다. **FILE**과 **TABLE**이 있는데, 8버전부터 기본값이 TABLE로 변경되었다. FILE로 설정하면 두 파일의 내용이 동기화되지 않아 복제가 재시작되지 못하는 경우가 발생했기 때문이다.

<br>

# 복제 타입
바이너리 로그에 기록된 **변경 내역을 식별하는 방법**에 따라 **바이너리 로그 파일 위치 기반 복제**와 **글로벌 트랜잭션 ID 기반 복제 방식**으로 나뉜다.

## 바이너리 로그 파일 위치 기반 복제
소스 서버의 바이너리 로그 **파일명과 파일 내의 위치**(offset)을 기반으로 각각의 바이너리 로그 이벤트를 식별하여 복제하는 방식이다.

> **! 주의할 점**
> 
> 복제에 참여한 서버들끼리 **고유한 server_id**를 가져야 한다. 왜냐하면 바이너리 로그 파일에 기록된 이벤트가 레플리카 서버의 id와 동일하면 레플리카 서버는 **해당 이벤트를 적용하지 않고 무시**하기 때문이다.


### 바이너리 로그 파일 위치 기반 복제에서 트랜잭션 건너뛰기
복제를 진행하다보면 에러로 인하여 종종 복제가 멈추는 현상이 발생한다. 대표적인 에러가 **중복 키** 에러다. 이런 경우 문제되는 트랜잭션을 건너뛸 수 있다.

<br>

## GTID 기반 복제
MySQL 5.5까지는 바이너리 로그 파일 위치 기반 복제만 가능했다. 문제는 위치 기반 식별이 **소스 서버에만 유효**했다는 점이다. 즉, 레플리카 서버에서도 동일한 파일의 동일한 위치에 저장된다는 보장이 존재하지 않아 **서로 다른 식별 값**을 갖게 된다. 이렇게 호환되지 않는 정보로 인해 복제 토폴로지를 변경하는 작업이 수월하지 않았다.

복제 토폴로지가 어렵다는 것은 장애 복구가 어렵다는 것을 의미하기도 한다. 그렇기 때문에 트랜잭션마다 고유한 ID를 갖게하여 **전체 서버가 같은 식별자를 갖게 하는 것**이 글로벌 트랜잭션 ID 기반 복제인 것이다.

<br>

### GTID 필요성
예를 들어 하나의 소스 서버에 두개의 레플리카 서버가 존재한다고 하자. 하나의 레플리카 서버가 SELECT 요청만 분산 받아 처리하고 있었고 다른 하나의 레플리카 서버는 복제를 하던 중 문제가 발생했다.

이어서 소스 서버에 문제가 생겼을 때, 우리는 SELECT 요청을 분산 받던 서버를 소스 서버로 승격시킬 수 있다. 문제는 기존에 SELECT 작업을 받던 서버이기 때문에 소스 서버의 트래픽이 모두 유입된다는 것이다. 다른 서버를 복제 서버로 위임하기도 어려운 상황이다.

왜냐하면 복제를 하던 중 오류가 발생했고 레플리카 서버가 갖고 있는 offset이 소스 서버 기준의 offset이기 때문에 복제를 재실행할 수 없기 때문이다.

만약 승격된 서버의 릴레이로그가 지워지지 않았다면 그 릴레이 로그를 받아 처리할 수 있지만 일반적으로 자동 삭제되기 때문에 제한적인 방법일 수 밖에 없어진다.

<br>

### 글로벌 트랜잭션 아이디
GTID는 각 트랜잭션과 연결된 고유 식별자로, 모든 서버에서도 고유하다. 바이너리 로그에 기록된 트랜잭션에 한해서만 할당되며 SELECT나 sql_log_bin이 비활성화된 상태에서 발생한 트랜잭션은 기록하지 않는다.

<br>

# 복제 데이터 포맷
지금까지는 바이너리 로그 파일의 이벤트들이 어떻게 식별되어 레플리카 서버에 전달되는지를 알아봤다. 지금부터는 이벤트가 어떤 형태로 저장되는지 알아보고자 한다. 실행된 **SQL문을 바이너리 로그에 저장**하는 **Statement** 방식과 **데이터 자체를 저장**하는 **Row** 방식으로 나뉜다. 둘 중 하나를 선택하거나 혼합된 방식을 선택할 수 있다.

<br>

## Statement 기반 바이너리 로그 포맷
SQL문을 바이너리 로그에 기록하는 방식이다. 바이너리 로그 파일 용량이 작아지기 때문에 **저장공간의 부담이 적고**, 복제할 때도 **좀 더 빠르게 처리**될 수 있다.

단점으로는 **비확정적으로 처리되는 쿼리가 실행**되면 복제 시 **서버 간 데이터가 달라질 수 있다**는 점이다. 일관성을 해칠 수 있는 쿼리 유형의 예시이다.

- DELETE/UPDATE 쿼리에서 ORDER BY 절 없이 LIMIT 사용
- SELECT .. FOR UPDATE나 SELECT .. FOR SHARE에서 NOWAIT나 SKIP LOCKED 옵션 사용
- 동일한 파라미터 값을 입력해도 결괏값이 달라질 수 있는 사용자 정의 함수나 프로시저를 사용하는 쿼리

Statement 포맷의 또 다른 단점은 **데이터 락을 더 많이 건다**는 점이다.

Statement 포맷을 사용할 때 제한사항이 있는데 "**Repeatable Read**" 이상이어야 한다는 점이다. 그 미만의 방식부터는 하나의 트랜잭션 내에서도 각 쿼리가 실행되는 시점마다 데이터 스냅샷이 달라질 수 있는데, 이로 인해 서버 간 데이터가 일치하지 않을 수도 있기 때문이다.

<br>

## Row 기반 바이너리 로그 포맷
소스 서버와 레플리카 서버 간 일관성을 가질 수 있는 방법이다. 비확정적 함수를 사용하더라도 결과값을 받아 처리하기 때문에 안전하게 복제가 가능하다. Statement에 비해 락이 최소화되기 때문에 락이 많이 걸리는 경우보다 더 빠르게 처리될 수 있다.

하지만 바이너리 로그 파일의 **크기가 커질 수 있는 단점**이 있다. BLOB 같은 값이 저장되거나 변경될 때도 커질 수 있다. 또한 **현재 실행 중인 쿼리가 어떤 것인지 직접 확인할 수 없다**.

참고로 **DDL 문**은 전부 **Statement** 포맷 형태로 바이너리 로그에 저장된다.

<br>

## Mixed 포맷
Mixed 포맷을 사용하면 기본적으로 Statement 포맷을 사용하다, 필요 시 자동으로 Row 포맷으로 변경된다. 복제 시 문제가 발생될 가능성이 있는 쿼리 형태일때 Row 포맷으로 변환되어 저장된다. ex) 비확정적 쿼리

<br>

## Row 포맷의 용량 최적화
Row 포맷은 Statement 포맷보다 바이너리 로그 파일의 용량이 커지는데 이를 줄일 두가지 방법이 존재한다.

### 바이너리 로그 Row 이미지
Row 포맷은 Statement 포맷보다 더 많은 **저장공간을 차지**하고 **네트워크 트래픽을 유발**할 가능성이 있다. MySQL은 이를 최소화하기 위해 binlog_row_image라는 변수로 레코드에 대해 어떤 칼럼을 기록할 것인지 결정한다.

full
- 모든 칼럼들의 값을 바이너리에 기록한다. insert, update, delete마다 달라진다. insert는 레코드의 모든 칼럼만 기록, update는 변경 전 레코드와 변경 후 레코드 칼럼들의 셋으로 기록, delete는 변경 전 레코드만 기록한다.

minimal
- 꼭 필요한 칼럼 값만 바이너리에 기록한다.
- insert 시에는 모든 칼럼과 auto-increment 값
- update 시에는 변경 전 레코드의 PK 값, 변경 후 레코드의 모든 컬럼 값
- delete 시에는 변경 전 레코드의 PK 값

noblob
- full과 동일하지만 BLOB이나 TEXT 칼럼에 변경이 발생하지 않으면 기록하지 않는다.

### 바이너리 로그 트랜잭션 압축
ROW 이미지를 조정해도 바이너리 로그 파일은 커질 수밖에 없다. 이를 위해 바이너리 로그 **보관 주기를 짧게 설정**하고 **로그 파일을 압축**한 뒤 전송하는 방법도 있다. 하지만 이 방법들도 한계가 존재한다. 따라서 변경한 데이터를 압축해서 바이너리 로그에 기록하는 기능이 도입되었다.

바이너리 로그 파일에 데이터를 저장할 때 압축해서 저장하고 **릴레이 로그에 기록할 때도 압축해서 저장**한 뒤, 레플리카 파일의 **데이터 파일에 적용할 때 압축을 해제**한다. 물론 인해 **CPU와 메모리 등의 서버 자원을 더 소모**할 수도 있다.

한가지 주의할 점은 **8.0.20 이상의 버전을 사용**해야 한다는 점이다.

# 복제 동기화 방식
## 비동기 복제
## 반동기 복제

# 복제 토폴로지
## 싱글 레플리카 복제 구성
## 멀티 레플리카 복제 구성
## 체인 복제 구성
## 듀얼 소스 복제 구성
## 멀티 소스 복제 구성
### 멀티 소스 복제 동작
### 멀티 소스 복제 구축

# 복제 고급 설정
## 지연된 복제
## 멀티 스레드 복제
### 데이터베이스 기반 멀티 스레드 복제
### Logical clock 기반 멀티 스레드 복제
#### 바이너리 로그 그룹 커밋
#### Commmit-parent 기반 Logical clock 방식
#### 잠금 기반 Logical clock 방식
#### WriteSet 기반 Logical clock 방식

## 크래시 세이프 복제
### 서버 장애와 복제 실패
### 복제 사용 형태별 크래시 세이프 복제 설정
## 필터링된 복제


### 키워드
- source server, replica server
- binary log, replay log
- binary log dump thread, replication i/o thread, replication sql thread
- 메타데이터 저장 형식
