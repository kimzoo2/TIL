# 2024.04
## 2024.04.01
- 운영체제
  - 단기, 중기, 장기 스케줄링 공부
  - 멀티 코어 환경에서의 동기화 문제 중 캐시 메모리 데이터 일관성 이야기를 듣게 되었다. 메모리 배리어라는 코드 실행 순서를 제어하는 방법으로 동시성 문제를 해결한다는 점이 인상 깊었다. 뭔가 옵티마이저 생각도 남.
- 넥스트 스텝
  - 스터디 준비.. js에 시달린다
- 프로젝트
  - 웹소켓 테스트 적용. HTTP session을 웹소켓 세션에 저장하는 핸드쉐이크 인터셉터를 적용해놓는 바람에 웹소켓 클라이언트에 요청할 때마다 오류가 발생한다. 웹소켓을 모킹하든지 HTTPSession에 데이터를 저장하든지, 결정해야 할 것 같다.
## 2024.04.02
- 운영체제
  - segmentation 정리
- 넥스트 스텝 스터디
- 도커 챌린지
  - 결국 컨테이너는 vm이라는 건데.. 어쩌다 isolation의 필요성이 대두되었는지 아직 명확히 이해 되지 않는다. 프로세스 간 간섭을 줄여서 보안을 강화하고 안정성을 제공한다고 하는데~~ 하이퍼바이저에서 컨테이너 기술로 넘어간 이유는 알겠지만 가상화에 대한 이유가 명확히 와닿지 않는다.

## 2024.04.03
- jit 컴파일러 정리
  - jvm 아키텍처에 대해서 좀 더 살펴봐야 할 것 같다. 클래스 로더, 실행 엔진, jvm 메모리 등. 특히 jvm 메모리 쪽의 개념이 덜 잡힌 것 같다.
- 프로젝트
  - Repository에 슬라이스 테스트 어노테이션 적용(@JdbcTest)해서 PR 리뷰 반영 중..인데 이전과는 다르게 롤백이 안 되고 있다. 원인 파악 중.

## 2024.04.08
- 운영체제
  - 시스템콜, 듀얼모드
  - 낙관적 락, 비관적 락, mvcc에 대해서 듣게 되었다. 낙관적 락은 쉽게 말해 충돌이 발생하지 않을거라 가정하고 충돌이 발생했을 때 해결하는 방식이다. 비관적 락은 충돌이 발생할거라 예상하고 데이터에 액세스 하기 전에 락을 걸어 충돌을 예방하는 방식이다. 이러한 락 방식이 성능을 저하시킬 가능성이 있고, 읽기 작업과 쓰기 작업이 동시에 일어나는 경우 서로 방해될 수 있기 때문에 mvcc가 나왔다고 한다. mvcc는 스냅샷을 생성해서 undo 영역에 생성하여 변경 기록을 저장하는 방식이다. 이는 isolation level이랑도 관련 있다고 한다.
- 프로젝트
  - 4월 3일에 발생했던 문제를 해결했다. 초기에 작성했던 스케줄러 test를 수정했다. 단위 테스트할 목적이었는데 mocking 객체를 spyBean으로 선언했더니, 실제 메소드가 수행되고 있었다. 그로 인해 다른 테스트로부터 독립적이어야하는데, 트랜잭션이 발생하여 다른 테스트 데이터에 영향을 주었다. 전체 테스트를 하지 않았다면 몰랐을 사실이다. 메서드를 명시적으로 모킹 처리하니 sql 초기화 쿼리도 지울 수 있었다.

## 2024.04.09
- 알고리즘
  - 병합 정렬에 대해서 공부함.. NlogN이라서 다른 정렬 방식보다 성능이 좋긴하나, 구현이 쉽지 않았다. 재귀함수를 이용해야 했는데 주말에 다시 구현해볼 생각이다.
- nextStep 및 스터디
  - 왜 테스트 목적으로 리플렉션을 사용하는 것을 지양해야 할까? 테스트 데이터를 생성하는 정도로는 괜찮으나, 개발자의 의도를 벗어난 코드를 테스트하기 때문이다. 그렇다는건 설게가 잘못되었다는 뜻, 이 부분을 기억하자.
- 도커 챌린지
  - github action을 통해 docker image를 만드는 작업까지는 수행했다. 금요일까지 스프링 프레임워크 image를 만들어 docker hub에 이미지를 올려볼 예정이다.
  - ci/cd 구축하는 목적은 개발부터 빌드, 배포까지의 소프트웨어 개발 단계를 간소화하고 자동화하는데 목적이 있다고 한다. 확실히 merge day를 두지 않고 배포할 수 있다는 장점이 있는 것 같다.
- 프로젝트
  - 날씨 api 구현을 위한 재설계 중..

## 2024.04.10
- 알고리즘
  - 퀵 소트 했는데 끝까지 구현 못해서 내일 할 예정. 평균 NlonN인데 최악이면 N제곱 시간복잡도라던데.. 
- 운영체제 겸 CS 스터디
  - https://www.figma.com/file/TGXdqUQEnL3yWun4StMUyb/OS?type=whiteboard&node-id=0%3A1&t=PlZb1vYzV2M0EHam-1
  - 시스템 구조 개요 훑었음. CPU가 i/o 작업 요청하고 응답 받을 때 어떤 인터럽트가 발생하는지, 정리해주셨는데 파편화되어 있던 지식이 조금 연결되는 느낌. DMA 컨트롤러랑 타이머 하드웨어 깜빡했다가 다시 떠오르는 중.
  - isolation level에 대한 이야기 들었음. read uncommitted, read committed, repeatable read, serializable 등. 발생하는 문제점도 들었는데 언두 로그랑 연관지어서 공부하는 게 좋긴 할 듯.
- 넥스트 스텝
  - 서로 다른 인터페이스를 한 단계 더 추상화하는 리팩토링을 진행했음. 리팩토링은 의식하고 하지 않으면 어려운 것 같다. 뭐가 냄새 나는 코드인지 알기도 어렵고.
- 프로젝트
  - 날씨 api 구현하려고 각 open api 요청, 응답 값 정리함. 테스트 겸 서버에서 HTTP 요청 날려보려고 했는데 방식이 두가지다. 넷플릭스에서 만든 OpenFeign이랑 WebClient.. 전자는 선언적 프로그래밍이 가능한데 블로킹 방식임. 후자는 논블로킹인데 러닝커브가 있어서 아직 결정을 못 함.
  - open api 요청도 추상화 할 예정.
