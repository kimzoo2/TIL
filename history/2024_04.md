# 2024.04
## 2024.04.01
- 운영체제
  - 단기, 중기, 장기 스케줄링 공부
  - 멀티 코어 환경에서의 동기화 문제 중 캐시 메모리 데이터 일관성 이야기를 듣게 되었다. 메모리 배리어라는 코드 실행 순서를 제어하는 방법으로 동시성 문제를 해결한다는 점이 인상 깊었다. 뭔가 옵티마이저 생각도 남.
- 넥스트 스텝
  - 스터디 준비.. js에 시달린다
- 프로젝트
  - 웹소켓 테스트 적용. HTTP session을 웹소켓 세션에 저장하는 핸드쉐이크 인터셉터를 적용해놓는 바람에 웹소켓 클라이언트에 요청할 때마다 오류가 발생한다. 웹소켓을 모킹하든지 HTTPSession에 데이터를 저장하든지, 결정해야 할 것 같다.
## 2024.04.02
- 운영체제
  - segmentation 정리
- 넥스트 스텝 스터디
- 도커 챌린지
  - 결국 컨테이너는 vm이라는 건데.. 어쩌다 isolation의 필요성이 대두되었는지 아직 명확히 이해 되지 않는다. 프로세스 간 간섭을 줄여서 보안을 강화하고 안정성을 제공한다고 하는데~~ 하이퍼바이저에서 컨테이너 기술로 넘어간 이유는 알겠지만 가상화에 대한 이유가 명확히 와닿지 않는다.

## 2024.04.03
- jit 컴파일러 정리
  - jvm 아키텍처에 대해서 좀 더 살펴봐야 할 것 같다. 클래스 로더, 실행 엔진, jvm 메모리 등. 특히 jvm 메모리 쪽의 개념이 덜 잡힌 것 같다.
- 프로젝트
  - Repository에 슬라이스 테스트 어노테이션 적용(@JdbcTest)해서 PR 리뷰 반영 중..인데 이전과는 다르게 롤백이 안 되고 있다. 원인 파악 중.

## 2024.04.08
- 운영체제
  - 시스템콜, 듀얼모드
  - 낙관적 락, 비관적 락, mvcc에 대해서 듣게 되었다. 낙관적 락은 쉽게 말해 충돌이 발생하지 않을거라 가정하고 충돌이 발생했을 때 해결하는 방식이다. 비관적 락은 충돌이 발생할거라 예상하고 데이터에 액세스 하기 전에 락을 걸어 충돌을 예방하는 방식이다. 이러한 락 방식이 성능을 저하시킬 가능성이 있고, 읽기 작업과 쓰기 작업이 동시에 일어나는 경우 서로 방해될 수 있기 때문에 mvcc가 나왔다고 한다. mvcc는 스냅샷을 생성해서 undo 영역에 생성하여 변경 기록을 저장하는 방식이다. 이는 isolation level이랑도 관련 있다고 한다.
- 프로젝트
  - 4월 3일에 발생했던 문제를 해결했다. 초기에 작성했던 스케줄러 test를 수정했다. 단위 테스트할 목적이었는데 mocking 객체를 spyBean으로 선언했더니, 실제 메소드가 수행되고 있었다. 그로 인해 다른 테스트로부터 독립적이어야하는데, 트랜잭션이 발생하여 다른 테스트 데이터에 영향을 주었다. 전체 테스트를 하지 않았다면 몰랐을 사실이다. 메서드를 명시적으로 모킹 처리하니 sql 초기화 쿼리도 지울 수 있었다.

## 2024.04.09
- 알고리즘
  - 병합 정렬에 대해서 공부함.. NlogN이라서 다른 정렬 방식보다 성능이 좋긴하나, 구현이 쉽지 않았다. 재귀함수를 이용해야 했는데 주말에 다시 구현해볼 생각이다.
- nextStep 및 스터디
  - 왜 테스트 목적으로 리플렉션을 사용하는 것을 지양해야 할까? 테스트 데이터를 생성하는 정도로는 괜찮으나, 개발자의 의도를 벗어난 코드를 테스트하기 때문이다. 그렇다는건 설게가 잘못되었다는 뜻, 이 부분을 기억하자.
- 도커 챌린지
  - github action을 통해 docker image를 만드는 작업까지는 수행했다. 금요일까지 스프링 프레임워크 image를 만들어 docker hub에 이미지를 올려볼 예정이다.
  - ci/cd 구축하는 목적은 개발부터 빌드, 배포까지의 소프트웨어 개발 단계를 간소화하고 자동화하는데 목적이 있다고 한다. 확실히 merge day를 두지 않고 배포할 수 있다는 장점이 있는 것 같다.
- 프로젝트
  - 날씨 api 구현을 위한 재설계 중..

## 2024.04.10
- 알고리즘
  - 퀵 소트 했는데 끝까지 구현 못해서 내일 할 예정. 평균 NlonN인데 최악이면 N제곱 시간복잡도라던데.. 
- 운영체제 겸 CS 스터디
  - https://www.figma.com/file/TGXdqUQEnL3yWun4StMUyb/OS?type=whiteboard&node-id=0%3A1&t=PlZb1vYzV2M0EHam-1
  - 시스템 구조 개요 훑었음. CPU가 i/o 작업 요청하고 응답 받을 때 어떤 인터럽트가 발생하는지, 정리해주셨는데 파편화되어 있던 지식이 조금 연결되는 느낌. DMA 컨트롤러랑 타이머 하드웨어 깜빡했다가 다시 떠오르는 중.
  - isolation level에 대한 이야기 들었음. read uncommitted, read committed, repeatable read, serializable 등. 발생하는 문제점도 들었는데 언두 로그랑 연관지어서 공부하는 게 좋긴 할 듯.
- 넥스트 스텝
  - 서로 다른 인터페이스를 한 단계 더 추상화하는 리팩토링을 진행했음. 리팩토링은 의식하고 하지 않으면 어려운 것 같다. 뭐가 냄새 나는 코드인지 알기도 어렵고.
- 프로젝트
  - 날씨 api 구현하려고 각 open api 요청, 응답 값 정리함. 테스트 겸 서버에서 HTTP 요청 날려보려고 했는데 방식이 두가지다. 넷플릭스에서 만든 OpenFeign이랑 WebClient.. 전자는 선언적 프로그래밍이 가능한데 블로킹 방식임. 후자는 논블로킹인데 러닝커브가 있어서 아직 결정을 못 함.
  - open api 요청도 추상화 할 예정.

## 2024.04.16
- 넥스트스텝
  - DI 프레임워크를 만들었음. DI를 적용할수록 변경에 용이하고 테스트하기 쉬운 코드가 된다.
  - 객체지향설계에 대해 다시 생각해보는 기회였다. 도메인 객체가 비즈니스 로직을 수행하도록 하는 것이 재사용성, 테스트 용이성, 유연성 등이 좋다고 하는데 와닿는 장점은 아니었다. 하지만 도메인 객체가 비즈니스 로직을 수행하게 함으로써 유효한 상태에 대한 보장이 되고 이를 테스트하면 그 자체가 기능명세가 된다는 장점을 알게 되었다. 협업 관점에서도 좋다고..
  - 도메인 객체는 의존성 관리를 하지 않나요?라는 질문을 했었는데, 이 질문에서 내가 **의존과 연관**을 혼용하고 있다는 사실을 깨달았다. 의존은 내부 상태로 가지고 있을 때, 의존은 매개변수로 전달 받거나 리턴 값으로 활용할 때다.

## 2024.04.17
- 운영체제
  - 프로세스의 개념, 컨텍스트 스위치, PCB, 프로세스 상태, 스케줄링 등에 대해서 다시 정리했다. OS 기본개념 파일에 정리하지 않았기 때문이다. 내일은 쓰레드랑 입출력 관련해서 정리해볼 에정이다. 조금씩 운영체제의 큰 개념들이 눈에 들어온다.
- 프로젝트
  - 기존에 사용하려던 날씨 API가 프로젝트의 요구사항을 반영하는 것 같지 않아서 기상청에서 제공하는 다른 API로 변경했다. 관련해서 LocalDateTime 정보를 스트링 타입으로 일자와 시간을 표현해야 해서 util 클래스를 만들어 테스트 코드도 작성했다. 아마 다른 날씨 API에서도 사용할 것 같다.
- 스터디
  - DB 관련된 문제에 대해 이야기를 나누었다. inno DB를 사용해도 테이블 전체의 row를 변경하려고 하면 테이블에 lock이 걸린다는 점을 간과했다. 그럼 트랜잭션 기준으로 lock이 걸리는걸까..? isolation level의 정의가 완벽하지 않다. propagation도 아마 까먹은 듯.. 시간 되면 다시 정리해보자.

## 2024.04.18
- 운영체제
  - 프로세스 생성과 종료, IPC에 대해 공부했다. copy on write를 오늘 오전 스터디 시간에 이야기를 들었는데 내가 아는 그 개념이 맞나 했다. 나는 메모리 관점에서만 알고 있었는데 알고 보니 프로세스도 쓰고 파일에서도 쓰는 컴퓨터 사이언스 개념이었다. 하나의 개념을 올바르게 이해하면 다른 개념을 이해하는데도 빠르다는 걸 다시금 깨닫는 순간이었다.
- 프로젝트
  - 같은 역할을 하지만 서로 다른 외부 API를 호출해야 한다. 두개를 한단계 더 추상화하는 인터페이스를 만들면 되지 않을까 생각했는데, 매개변수가 다르다는 걸 깜빡했다. 나는 feign client를 쓸 생각이라 구현체가 아니라, 인터페이스에 bean이 등록되어서 잠깐 이게 뭐지 싶었다. 작성해둔 인터페이스 기반으로 feign client가 구현체를 생성해서 빈으로 등록해주는 걸까? 그렇다면 매개변수가 다르면 템플릿 메소드 패턴이라도 둬서 흐름을 제어해야 하나, 고민이 들었다. 이건 내일 멘토님한테 메일 보내봐야지..
